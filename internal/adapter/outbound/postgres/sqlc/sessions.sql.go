// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSessions = `-- name: CountSessions :one
SELECT COUNT(*)
FROM sessions
WHERE ($1::text IS NULL OR user_id = $1)
  AND ($2::text IS NULL OR tenant_id = $2)
  AND ($3::bool = FALSE OR (revoked_at IS NULL AND expires_at > NOW()))
`

type CountSessionsParams struct {
	UserID     pgtype.Text `json:"user_id"`
	TenantID   pgtype.Text `json:"tenant_id"`
	ActiveOnly bool        `json:"active_only"`
}

func (q *Queries) CountSessions(ctx context.Context, arg CountSessionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSessions, arg.UserID, arg.TenantID, arg.ActiveOnly)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSession = `-- name: CreateSession :exec
INSERT INTO sessions (id, user_id, user_did, tenant_id, refresh_token_hash, expires_at, created_at, revoked_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateSessionParams struct {
	ID               string             `json:"id"`
	UserID           string             `json:"user_id"`
	UserDid          string             `json:"user_did"`
	TenantID         pgtype.Text        `json:"tenant_id"`
	RefreshTokenHash string             `json:"refresh_token_hash"`
	ExpiresAt        time.Time          `json:"expires_at"`
	CreatedAt        time.Time          `json:"created_at"`
	RevokedAt        pgtype.Timestamptz `json:"revoked_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.Exec(ctx, createSession,
		arg.ID,
		arg.UserID,
		arg.UserDid,
		arg.TenantID,
		arg.RefreshTokenHash,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.RevokedAt,
	)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :execrows
DELETE FROM sessions
WHERE expires_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExpiredSessions)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findActiveSessionsByUserID = `-- name: FindActiveSessionsByUserID :many
SELECT id, user_id, user_did, tenant_id, refresh_token_hash, expires_at, created_at, revoked_at
FROM sessions
WHERE user_id = $1
  AND revoked_at IS NULL
  AND expires_at > NOW()
ORDER BY created_at DESC
`

func (q *Queries) FindActiveSessionsByUserID(ctx context.Context, userID string) ([]Session, error) {
	rows, err := q.db.Query(ctx, findActiveSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserDid,
			&i.TenantID,
			&i.RefreshTokenHash,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.RevokedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSessionByID = `-- name: FindSessionByID :one
SELECT id, user_id, user_did, tenant_id, refresh_token_hash, expires_at, created_at, revoked_at
FROM sessions
WHERE id = $1
`

func (q *Queries) FindSessionByID(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRow(ctx, findSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserDid,
		&i.TenantID,
		&i.RefreshTokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RevokedAt,
	)
	return i, err
}

const findSessionByRefreshTokenHash = `-- name: FindSessionByRefreshTokenHash :one
SELECT id, user_id, user_did, tenant_id, refresh_token_hash, expires_at, created_at, revoked_at
FROM sessions
WHERE refresh_token_hash = $1
`

func (q *Queries) FindSessionByRefreshTokenHash(ctx context.Context, refreshTokenHash string) (Session, error) {
	row := q.db.QueryRow(ctx, findSessionByRefreshTokenHash, refreshTokenHash)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserDid,
		&i.TenantID,
		&i.RefreshTokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RevokedAt,
	)
	return i, err
}

const listSessions = `-- name: ListSessions :many
SELECT id, user_id, user_did, tenant_id, refresh_token_hash, expires_at, created_at, revoked_at
FROM sessions
WHERE ($3::text IS NULL OR user_id = $3)
  AND ($4::text IS NULL OR tenant_id = $4)
  AND ($5::bool = FALSE OR (revoked_at IS NULL AND expires_at > NOW()))
ORDER BY
    CASE WHEN $6 = 'created_at' AND $7 = 'asc' THEN created_at END ASC,
    CASE WHEN $6 = 'created_at' AND $7 = 'desc' THEN created_at END DESC,
    CASE WHEN $6 = 'expires_at' AND $7 = 'asc' THEN expires_at END ASC,
    CASE WHEN $6 = 'expires_at' AND $7 = 'desc' THEN expires_at END DESC,
    created_at DESC
LIMIT $1 OFFSET $2
`

type ListSessionsParams struct {
	Limit      int32       `json:"limit"`
	Offset     int32       `json:"offset"`
	UserID     pgtype.Text `json:"user_id"`
	TenantID   pgtype.Text `json:"tenant_id"`
	ActiveOnly bool        `json:"active_only"`
	SortBy     interface{} `json:"sort_by"`
	SortOrder  interface{} `json:"sort_order"`
}

func (q *Queries) ListSessions(ctx context.Context, arg ListSessionsParams) ([]Session, error) {
	rows, err := q.db.Query(ctx, listSessions,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.TenantID,
		arg.ActiveOnly,
		arg.SortBy,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserDid,
			&i.TenantID,
			&i.RefreshTokenHash,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.RevokedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAllSessionsByUserID = `-- name: RevokeAllSessionsByUserID :execrows
UPDATE sessions
SET revoked_at = NOW()
WHERE user_id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeAllSessionsByUserID(ctx context.Context, userID string) (int64, error) {
	result, err := q.db.Exec(ctx, revokeAllSessionsByUserID, userID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const revokeSessionByID = `-- name: RevokeSessionByID :exec
UPDATE sessions
SET revoked_at = NOW()
WHERE id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeSessionByID(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, revokeSessionByID, id)
	return err
}

const updateSession = `-- name: UpdateSession :exec
UPDATE sessions
SET refresh_token_hash = $2, expires_at = $3, revoked_at = $4
WHERE id = $1
`

type UpdateSessionParams struct {
	ID               string             `json:"id"`
	RefreshTokenHash string             `json:"refresh_token_hash"`
	ExpiresAt        time.Time          `json:"expires_at"`
	RevokedAt        pgtype.Timestamptz `json:"revoked_at"`
}

func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.Exec(ctx, updateSession,
		arg.ID,
		arg.RefreshTokenHash,
		arg.ExpiresAt,
		arg.RevokedAt,
	)
	return err
}
